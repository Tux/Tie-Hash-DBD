.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "STDIN 1"
.TH STDIN 1 "2022-01-01" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Hash::DBD \- tie a plain hash to a database table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use DBI;
\&  use Tie::Hash::DBD;
\&
\&  my $dbh = DBI\->connect ("dbi:Pg:", ...);
\&
\&  tie my %hash, "Tie::Hash::DBD", "dbi:SQLite:dbname=db.tie";
\&  tie my %hash, "Tie::Hash::DBD", $dbh;
\&  tie my %hash, "Tie::Hash::DBD", $dbh, {
\&      tbl => "t_tie_analysis",
\&      key => "h_key",
\&      fld => "h_value",
\&      str => "Storable",
\&      trh => 0,
\&      };
\&
\&  $hash{key} = $value;  # INSERT
\&  $hash{key} = 3;       # UPDATE
\&  delete $hash{key};    # DELETE
\&  $value = $hash{key};  # SELECT
\&  %hash = ();           # CLEAR
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has been created to act as a drop-in replacement for modules
that tie straight perl hashes to disk, like \f(CW\*(C`DB_File\*(C'\fR. When the running
system does not have enough memory to hold large hashes, and disk-tieing
won't work because there is not enough space, it works quite well to tie
the hash to a database, which preferable runs on a different server.
.PP
This module ties a hash to a database table using \fBonly\fR a \f(CW\*(C`key\*(C'\fR and a
\&\f(CW\*(C`value\*(C'\fR field. If no tables specification is passed, this will create a
temporary table with \f(CW\*(C`h_key\*(C'\fR for the key field and a \f(CW\*(C`h_value\*(C'\fR for the
value field.
.PP
I think it would make sense  to merge the functionality that this module
provides into \f(CW\*(C`Tie::DBI\*(C'\fR.
.SH "tie"
.IX Header "tie"
The tie call accepts two arguments:
.SS "Database"
.IX Subsection "Database"
The first argument is the connection specifier.  This is either and open
database handle or a \f(CW\*(C`DBI_DSN\*(C'\fR string.
.PP
If this argument is a valid handle, this module does not open a database
all by itself, but uses the connection provided in the handle.
.PP
If the first argument is a scalar, it is used as \s-1DSN\s0 for \s-1DBI\-\s0>connect ().
.PP
Supported \s-1DBD\s0 drivers include DBD::Pg, DBD::SQLite, \s-1DBD::CSV,\s0 DBD::MariaDB,
DBD::mysql, DBD::Oracle, DBD::Unify, and DBD::Firebird.  Note that due to
limitations they won't all perform equally well. Firebird is not tested
anymore.
.PP
DBD::Pg and DBD::SQLite have an unexpected great performance when server
is the local system. DBD::SQLite is even almost as fast as DB_File.
.PP
The current implementation appears to be extremely slow for \s-1CSV,\s0 as
expected, MariaDB/mysql, and Unify. For Unify and MariaDB/mysql that is
because these do not allow indexing on the key field so they cannot be
set to be primary key.
.PP
When using \s-1DBD::CSV\s0 with Text::CSV_XS version 1.02 or newer, it might be
wise to disable utf8 encoding (only supported as of \s-1DBD::CSV\-0.48\s0):
.PP
.Vb 1
\& "dbi:CSV:f_ext=.csv/r;csv_null=1;csv_decode_utf8=0"
.Ve
.SS "Options"
.IX Subsection "Options"
The second argument is optional and should \- if passed \- be a hashref to
options. The following options are recognized:
.IP "tbl" 2
.IX Item "tbl"
Defines the name of the table to be used. If none is passed, a new table
is created with a unique name like \f(CW\*(C`t_tie_dbdh_42253_1\*(C'\fR. When possible,
the table is created as \fItemporary\fR. After the session, this table will
be dropped.
.Sp
If a table name is provided, it will be checked for existence. If found,
it will be used with the specified \f(CW\*(C`key\*(C'\fR and \f(CW\*(C`fld\*(C'\fR.  Otherwise it will
be created with \f(CW\*(C`key\*(C'\fR and \f(CW\*(C`fld\*(C'\fR, but it will not be dropped at the end
of the session.
.Sp
If a table name is provided, \f(CW\*(C`AutoCommit\*(C'\fR will be \*(L"On\*(R" for persistence,
unless you provide a true \f(CW\*(C`trh\*(C'\fR attribute.
.IP "key" 2
.IX Item "key"
Defines the name of the key field in the database table.  The default is
\&\f(CW\*(C`h_key\*(C'\fR.
.IP "ktp" 2
.IX Item "ktp"
Defines the type of the key field in the database table.  The default is
depending on the underlying database. Probably unwise to change.
.Sp
If the database allows the type to be indexed, the key field is defined
as primary key.
.Sp
Note that if your data conflicts with internal (database)limits, like
having a key that is longer than what the index on a primary key permits,
you should probably want to create the table yourself with a different
index or field type.
.IP "fld" 2
.IX Item "fld"
Defines the name of the value field in the database table.   The default
is \f(CW\*(C`h_value\*(C'\fR.
.IP "vtp" 2
.IX Item "vtp"
Defines the type of the fld field in the database table.  The default is
depending on the underlying database and most likely some kind of \s-1BLOB.\s0
.IP "str" 2
.IX Item "str"
Defines the required persistence module.   Currently supports the use of
\&\f(CW\*(C`Storable\*(C'\fR, \f(CW\*(C`Sereal\*(C'\fR,  \f(CW\*(C`JSON\*(C'\fR, \f(CW\*(C`JSON::Syck\*(C'\fR,  \f(CW\*(C`YAML\*(C'\fR, \f(CW\*(C`YAML::Syck\*(C'\fR
and \f(CW\*(C`XML::Dumper\*(C'\fR.
.Sp
The default is undefined.
.Sp
Passing any other value will cause a \f(CW\*(C`croak\*(C'\fR.
.Sp
If you want to preserve Encoding on the hash values, you should use this
feature. (except where \f(CW\*(C`PV8\*(C'\fR has a \f(CW\*(C`\-\*(C'\fR in the table below)
.Sp
Here is a table of supported data types given a data structure like this:
.Sp
.Vb 10
\&    my %deep = (
\&        UND => undef,
\&        IV  => 1,
\&        NV  => 3.14159265358979,
\&        PV  => "string",
\&        PV8 => "ab\encd\ex{20ac}\et",
\&        PVM => $!,
\&        RV  => \e$DBD,
\&        AR  => [ 1..2 ],
\&        HR  => { key => "value" },
\&        OBJ => ( bless { auto_diag => 1 }, "Text::CSV_XS" ),
\&        RX  => qr{^re[gG]e?x},
\&        FMT => *{$::{STDOUT}}{FORMAT},
\&        CR  => sub { "code"; },
\&        GLB => *STDERR,
\&        IO  => *{$::{STDERR}}{IO},
\&        );
\&
\&              UND  IV  NV  PV PV8 PVM  RV  AR  HR OBJ  RX FMT  CR GLB  IO
\& No streamer   x   x   x   x   x   x   x   x   x   x   \-   \-   \-   \-   \-
\& Storable      x   x   x   x   x   x   x   x   x   x   \-   \-   \-   \-   \-
\& Sereal        x   x   x   x   x   x   x   x   x   x   x   x   \-   \-   \-
\& JSON          x   x   x   x   x   x   \-   x   x   \-   \-   \-   \-   \-   \-
\& JSON::Syck    x   x   x   x   x   \-   \-   x   x   x   \-   x   \-   \-   \-
\& YAML          x   x   x   x   x   \-   x   x   x   x   x   x   \-   \-   \-
\& YAML::Syck    x   x   x   x   x   \-   x   x   x   x   \-   x   \-   \-   \-
\& XML::Dumper   x   x   x   x   x   x   x   x   x   x   \-   x   \-   \-   \-
\& FreezeThaw    x   x   x   x   \-   x   x   x   x   x   \-   x   \-   x   \-
\& Bencode       \-   x   x   x   \-   x   \-   x   x   \-   \-   \-   \-   x   \-
.Ve
.Sp
So, \f(CW\*(C`Storable\*(C'\fR does not support persistence of types \f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`REGEXP\*(C'\fR,
\&\f(CW\*(C`FORMAT\*(C'\fR, \f(CW\*(C`IO\*(C'\fR, and \f(CW\*(C`GLOB\*(C'\fR. Be sure to test if all of your data types
are supported by the serializer you choose. \s-1YMMV.\s0
.Sp
\&\*(L"No streamer\*(R"  might work inside the current process if reference values
are stored, but it is highly unlikely they are persistent.
.Sp
Also note that this module does not yet support dynamic deep structures.
See Nesting and deep structures.
.IP "trh" 2
.IX Item "trh"
Use transaction Handles. By default none of the operations is guarded by
transaction handling for speed reasons. Set \f(CW\*(C`trh\*(C'\fR to a true value cause
all actions to be surrounded by  \f(CW\*(C`begin_work\*(C'\fR and \f(CW\*(C`commit\*(C'\fR.  Note that
this may have a big impact on speed.
.SS "Encoding"
.IX Subsection "Encoding"
\&\f(CW\*(C`Tie::Hash::DBD\*(C'\fR stores keys and values as binary data. This means that
all Encoding and magic is lost when the data is stored, and thus is also
not available when the data is restored,  hence all internal information
about the data is also lost, which includes the \f(CW\*(C`UTF8\*(C'\fR flag.
.PP
If you want to preserve the \f(CW\*(C`UTF8\*(C'\fR flag you will need to store internal
flags and use the streamer option:
.PP
.Vb 1
\&  tie my %hash, "Tie::Hash::DBD", { str => "Storable" };
.Ve
.PP
If you do not want the performance impact of Storable just to be able to
store and retrieve \s-1UTF\-8\s0 values, there are two ways to do so:
.PP
.Vb 3
\&  # Use utf\-8 from database
\&  tie my %hash, "Tie::Hash::DBD", "dbi:Pg:", { vtp => "text" };
\&  $hash{foo} = "The teddybear costs \ex{20ac} 45.95";
\&
\&  # use Encode
\&  tie my %hash, "Tie::Hash::DBD", "dbi:Pg:";
\&  $hash{foo} = encode "UTF\-8", "The teddybear costs \ex{20ac} 45.95";
.Ve
.PP
Note  that using Encode will allow other binary data too where using the
database encoding does not:
.PP
.Vb 1
\&  $hash{foo} = pack "L>A*", time, encode "UTF\-8", "Price: \ex{20ac} 45.95";
.Ve
.SS "Nesting and deep structures"
.IX Xref "nesting"
.IX Subsection "Nesting and deep structures"
\&\f(CW\*(C`Tie::Hash::DBD\*(C'\fR stores keys and values as binary data. This means that
all structure is lost when the data is stored and not available when the
data is restored. To maintain deep structures, use the streamer option:
.PP
.Vb 1
\&  tie my %hash, "Tie::Hash::DBD", { str => "Storable" };
.Ve
.PP
Note that changes inside deep structures do not work. See \*(L"\s-1TODO\*(R"\s0.
.SH "METHODS"
.IX Header "METHODS"
.SS "drop ()"
.IX Subsection "drop ()"
If a table was used with persistence, the table will not be dropped when
the \f(CW\*(C`untie\*(C'\fR is called.  Dropping can be forced using the \f(CW\*(C`drop\*(C'\fR method
at any moment while the hash is tied:
.PP
.Vb 1
\&  (tied %hash)\->drop;
.Ve
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
The only real prerequisite is \s-1DBI\s0 but of course that uses the \s-1DBD\s0 driver
of your choice. Some drivers are (very) actively maintained.  Be sure to
to use recent Modules.  DBD::SQLite for example seems to require version
1.29 or up.
.SH "RESTRICTIONS and LIMITATIONS"
.IX Header "RESTRICTIONS and LIMITATIONS"
.IP "\(bu" 2
As Oracle does not allow \s-1BLOB, CLOB\s0 or \s-1LONG\s0 to be indexed or selected on,
the keys will be converted to \s-1ASCII\s0 for Oracle. The maximum length for a
converted key in Oracle is 4000 characters. The fact that the key has to
be converted to \s-1ASCII\s0 representation,  also excludes \f(CW\*(C`undef\*(C'\fR as a valid
key value.
.Sp
\&\f(CW\*(C`DBD::Oracle\*(C'\fR limits the size of BLOB-reads to 4kb by default, which is
too small for reasonable data structures.  Tie::Hash::DBD locally raises
this value to 4Mb, which is still an arbitrary limit.
.IP "\(bu" 2
\&\f(CW\*(C`Storable\*(C'\fR does not support persistence of perl types \f(CW\*(C`IO\*(C'\fR, \f(CW\*(C`REGEXP\*(C'\fR,
\&\f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`FORMAT\*(C'\fR, and \f(CW\*(C`GLOB\*(C'\fR.  Future extensions might implement some
alternative streaming modules, like \f(CW\*(C`Data::Dump::Streamer\*(C'\fR or use mixin
approaches that enable you to fit in your own.
.IP "\(bu" 2
Note that neither \s-1DBD::CSV\s0 nor DBD::Unify support \f(CW\*(C`AutoCommit\*(C'\fR.
.IP "\(bu" 2
For now, Firebird does not support \f(CW\*(C`TEXT\*(C'\fR (or \f(CW\*(C`CLOB\*(C'\fR) in DBD::Firebird
at a level required by Tie::Hash::DBD. Neither does it support arbitrary
length index on \f(CW\*(C`VARCHAR\*(C'\fR fields so it can neither be a primary key nor
can it be the subject of a (unique) index hence large sets will be slow.
.Sp
Firebird support is stalled.
.SH "TODO"
.IX Header "TODO"
.IP "Update on deep changes" 2
.IX Item "Update on deep changes"
Currently,  nested structures do not get updated when it is an change in
a deeper part.
.Sp
.Vb 1
\&  tie my %hash, "Tie::Hash::DBD", $dbh, { str => "Storable" };
\&
\&  $hash{deep} = {
\&      int  => 1,
\&      str  => "foo",
\&      };
\&
\&  $hash{deep}{int}++; # No effect :(
.Ve
.IP "Documentation" 2
.IX Item "Documentation"
Better document what the implications are of storing  \fIdata\fR content in
a database and restoring that. It will not be fool proof.
.IP "Mixins" 2
.IX Item "Mixins"
Maybe: implement a feature that would enable plugins or mixins to do the
streaming or preservation of other data attributes.
.SH "AUTHOR"
.IX Header "AUTHOR"
H.Merijn Brand <h.m.brand@xs4all.nl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010\-2022 H.Merijn Brand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI,\s0 Tie::DBI, Tie::Hash, Tie::Array::DBD, Tie::Hash::RedisDB, Redis::Hash,
DBM::Deep, Storable, Sereal, \s-1JSON,\s0 JSON::Syck, \s-1YAML,\s0 YAML::Syck, XML::Dumper,
Bencode, FreezeThaw
